import React, {
  createContext,
  useContext,
  useState,
  useEffect,
  useMemo,
  useCallback,
} from "react";
import type {
  ProcessedVulnerability,
  FilterState,
  DashboardStats,
  AnalysisMode,
} from "../types/vulnerability";
import {
  loadVulnerabilityData,
  processVulnerabilityData,
  calculateStats,
  filterByKaiStatus,
} from "../utils/dataLoader";
import { applyFilters, sortVulnerabilities } from "../utils/filterUtils";
import { config } from "../config";

interface VulnerabilityContextType {
  // Data
  allVulnerabilities: ProcessedVulnerability[];
  filteredVulnerabilities: ProcessedVulnerability[];
  stats: DashboardStats;

  // Loading state
  isLoading: boolean;
  loadingProgress: number;
  error: string | null;

  // Filters
  filters: FilterState;
  setFilters: (filters: FilterState) => void;
  resetFilters: () => void;

  // Analysis mode
  analysisMode: AnalysisMode;
  setAnalysisMode: (mode: AnalysisMode) => void;

  // Sorting
  sortBy: keyof ProcessedVulnerability;
  sortOrder: "asc" | "desc";
  setSorting: (
    sortBy: keyof ProcessedVulnerability,
    sortOrder: "asc" | "desc",
  ) => void;

  // Comparison
  selectedForComparison: Set<string>;
  toggleComparison: (id: string) => void;
  clearComparison: () => void;

  // Actions
  refreshData: () => Promise<void>;
}

const defaultFilters: FilterState = {
  severity: [],
  kaiStatus: [],
  packageType: [],
  riskFactors: [],
  searchQuery: "",
  status: [],
  dateRange: {
    start: null,
    end: null,
  },
};

const analysisModes: Record<string, AnalysisMode> = {
  all: {
    mode: "all",
    label: "All Vulnerabilities",
    filterToKaiStatus: null, // Show all
  },
  analysis: {
    mode: "analysis",
    label: "Analysis",
    filterToKaiStatus: ["invalid - norisk"], // Show ONLY manual analysis vulnerabilities
  },
  aiAnalysis: {
    mode: "ai-analysis",
    label: "AI Analysis",
    filterToKaiStatus: ["ai-invalid-norisk"], // Show ONLY AI analysis vulnerabilities
  },
};

const VulnerabilityContext = createContext<
  VulnerabilityContextType | undefined
>(undefined);

export function VulnerabilityProvider({
  children,
}: {
  children: React.ReactNode;
}) {
  const [allVulnerabilities, setAllVulnerabilities] = useState<
    ProcessedVulnerability[]
  >([]);
  const [isLoading, setIsLoading] = useState(true);
  const [loadingProgress, setLoadingProgress] = useState(0);
  const [error, setError] = useState<string | null>(null);

  const [filters, setFilters] = useState<FilterState>(defaultFilters);
  const [analysisMode, setAnalysisMode] = useState<AnalysisMode>(
    analysisModes.all,
  );
  const [sortBy, setSortByState] =
    useState<keyof ProcessedVulnerability>("published");
  const [sortOrder, setSortOrderState] = useState<"asc" | "desc">("desc");
  const [selectedForComparison, setSelectedForComparison] = useState<
    Set<string>
  >(new Set());

  // Load data on mount
  useEffect(() => {
    loadData();
  }, []);

  const loadData = async () => {
    try {
      setIsLoading(true);
      setError(null);
      setLoadingProgress(0);

      // Load data from configured source (GitHub or local)
      const data = await loadVulnerabilityData(
        config.dataSourceUrl,
        (progress) => {
          setLoadingProgress(progress);
        }
      );

      const processed = processVulnerabilityData(data);
      setAllVulnerabilities(processed);
    } catch (err) {
      setError(err instanceof Error ? err.message : "Failed to load data");
      console.error("Error loading data:", err);
    } finally {
      setIsLoading(false);
    }
  };

  // Apply analysis mode filtering
  const modeFilteredVulnerabilities = useMemo(() => {
    return filterByKaiStatus(
      allVulnerabilities,
      analysisMode.filterToKaiStatus,
    );
  }, [allVulnerabilities, analysisMode]);

  // Apply user filters
  const filteredVulnerabilities = useMemo(() => {
    let result = applyFilters(modeFilteredVulnerabilities, filters);
    result = sortVulnerabilities(result, sortBy, sortOrder);
    return result;
  }, [modeFilteredVulnerabilities, filters, sortBy, sortOrder]);

  // Calculate stats based on mode-filtered data
  const stats = useMemo(() => {
    return calculateStats(modeFilteredVulnerabilities);
  }, [modeFilteredVulnerabilities]);

  const resetFilters = useCallback(() => {
    setFilters(defaultFilters);
  }, []);

  const setSorting = useCallback(
    (newSortBy: keyof ProcessedVulnerability, newSortOrder: "asc" | "desc") => {
      setSortByState(newSortBy);
      setSortOrderState(newSortOrder);
    },
    [],
  );

  const toggleComparison = useCallback((id: string) => {
    setSelectedForComparison((prev) => {
      const next = new Set(prev);
      if (next.has(id)) {
        next.delete(id);
      } else {
        // Limit to 5 items for comparison
        if (next.size < 5) {
          next.add(id);
        }
      }
      return next;
    });
  }, []);

  const clearComparison = useCallback(() => {
    setSelectedForComparison(new Set());
  }, []);

  const refreshData = useCallback(async () => {
    await loadData();
  }, []);

  const value: VulnerabilityContextType = {
    allVulnerabilities: modeFilteredVulnerabilities,
    filteredVulnerabilities,
    stats,
    isLoading,
    loadingProgress,
    error,
    filters,
    setFilters,
    resetFilters,
    analysisMode,
    setAnalysisMode,
    sortBy,
    sortOrder,
    setSorting,
    selectedForComparison,
    toggleComparison,
    clearComparison,
    refreshData,
  };

  return (
    <VulnerabilityContext.Provider value={value}>
      {children}
    </VulnerabilityContext.Provider>
  );
}

export function useVulnerability() {
  const context = useContext(VulnerabilityContext);
  if (!context) {
    throw new Error(
      "useVulnerability must be used within VulnerabilityProvider",
    );
  }
  return context;
}

export { analysisModes };
